"""System validator - main orchestrator for PV system validation.

This module provides the main SystemValidator class that coordinates all
validation activities including electrical checks, code compliance, performance
validation, and report generation.
"""

import uuid
from datetime import datetime
from typing import Dict, List, Optional

from src.models.validation_models import (
    ComplianceStatus,
    IssueItem,
    IssueSeverity,
    PerformanceMetrics,
    SystemConfiguration,
    ValidationReport,
    ValidationResult,
)

from .code_compliance_checker import CodeComplianceChecker
from .engineering_calculation_verifier import EngineeringCalculationVerifier
from .performance_validator import PerformanceValidator


class SystemValidator:
    """Main system validator orchestrating all validation activities.

    Coordinates electrical validation, code compliance checking, performance
    validation, and report generation for PV systems. Provides comprehensive
    system validation with automated checks and professional reporting.

    Attributes:
        config: System configuration to validate
        performance_metrics: Optional performance metrics for validation
        compliance_checker: Code compliance checker instance
        calc_verifier: Engineering calculation verifier instance
        performance_validator: Performance validator instance
        validation_report: Generated validation report
    """

    def __init__(
        self,
        config: SystemConfiguration,
        performance_metrics: Optional[PerformanceMetrics] = None,
    ) -> None:
        """Initialize system validator.

        Args:
            config: System configuration to validate
            performance_metrics: Optional performance metrics to validate
        """
        self.config = config
        self.performance_metrics = performance_metrics

        # Initialize validators
        self.compliance_checker = CodeComplianceChecker(config)
        self.calc_verifier = EngineeringCalculationVerifier(config)
        self.performance_validator = PerformanceValidator(config, performance_metrics)

        # Validation report (generated by validate_complete_design)
        self.validation_report: Optional[ValidationReport] = None

    def check_electrical_codes(self) -> List[ValidationResult]:
        """Check electrical code compliance (NEC, IEC).

        Performs comprehensive electrical code compliance checks including
        voltage limits, current ratings, overcurrent protection, grounding,
        and all applicable electrical codes.

        Returns:
            List of validation results for electrical code compliance
        """
        results: List[ValidationResult] = []

        # NEC compliance
        nec_results = self.compliance_checker.nec_690_compliance()

        # Check for failures
        nec_failures = [r for r in nec_results if r.status == ComplianceStatus.FAILED]
        nec_warnings = [r for r in nec_results if r.status == ComplianceStatus.WARNING]

        # Determine overall status
        if nec_failures:
            nec_status = ComplianceStatus.FAILED
        elif nec_warnings:
            nec_status = ComplianceStatus.WARNING
        else:
            nec_status = ComplianceStatus.PASSED

        # Create issues for failures
        nec_issues = []
        for failure in nec_failures:
            nec_issues.append(
                IssueItem(
                    severity=IssueSeverity.ERROR,
                    category="electrical",
                    code=f"NEC_{failure.section.replace('.', '_')}",
                    message=f"NEC {failure.section} violation: {failure.requirement}",
                    location="Electrical System",
                    recommendation=failure.notes or "Review and correct per NEC requirements",
                    reference=f"NEC {self.compliance_checker.nec_version} Article {failure.section}",
                )
            )

        results.append(
            ValidationResult(
                check_name="NEC 690 Compliance",
                category="electrical",
                status=nec_status,
                issues=nec_issues,
                compliance_checks=nec_results,
                summary=(
                    f"NEC Article 690 compliance check: {len(nec_results)} checks performed, "
                    f"{len(nec_failures)} failures, {len(nec_warnings)} warnings."
                ),
            )
        )

        # IEC compliance
        iec_results = self.compliance_checker.iec_60364_compliance()

        iec_failures = [r for r in iec_results if r.status == ComplianceStatus.FAILED]
        iec_warnings = [r for r in iec_results if r.status == ComplianceStatus.WARNING]

        if iec_failures:
            iec_status = ComplianceStatus.FAILED
        elif iec_warnings:
            iec_status = ComplianceStatus.WARNING
        else:
            iec_status = ComplianceStatus.PASSED

        iec_issues = []
        for failure in iec_failures:
            iec_issues.append(
                IssueItem(
                    severity=IssueSeverity.ERROR,
                    category="electrical",
                    code=f"IEC_{failure.section.replace('.', '_')}",
                    message=f"IEC {failure.section} violation: {failure.requirement}",
                    location="Electrical System",
                    recommendation=failure.notes or "Review and correct per IEC requirements",
                    reference=f"IEC {self.compliance_checker.iec_version} Section {failure.section}",
                )
            )

        results.append(
            ValidationResult(
                check_name="IEC 60364 Compliance",
                category="electrical",
                status=iec_status,
                issues=iec_issues,
                compliance_checks=iec_results,
                summary=(
                    f"IEC 60364-7-712 compliance check: {len(iec_results)} checks performed, "
                    f"{len(iec_failures)} failures, {len(iec_warnings)} warnings."
                ),
            )
        )

        return results

    def verify_structural_requirements(self) -> List[ValidationResult]:
        """Verify structural and building code requirements.

        Checks structural requirements including wind loads, snow loads,
        roof loading, and building code compliance.

        Returns:
            List of validation results for structural requirements
        """
        results: List[ValidationResult] = []

        # Building code checks
        building_results = self.compliance_checker.building_code_checks()

        building_failures = [r for r in building_results if r.status == ComplianceStatus.FAILED]
        building_warnings = [r for r in building_results if r.status == ComplianceStatus.WARNING]

        if building_failures:
            building_status = ComplianceStatus.FAILED
        elif building_warnings:
            building_status = ComplianceStatus.WARNING
        else:
            building_status = ComplianceStatus.PASSED

        building_issues = []
        for failure in building_failures:
            building_issues.append(
                IssueItem(
                    severity=IssueSeverity.ERROR,
                    category="structural",
                    code=f"IBC_{failure.section.replace('.', '_')}",
                    message=f"Building code {failure.section} issue: {failure.requirement}",
                    location="Structural System",
                    recommendation=failure.notes or "Review structural design",
                    reference=f"{failure.code_name} Section {failure.section}",
                )
            )

        results.append(
            ValidationResult(
                check_name="Building Code Compliance",
                category="structural",
                status=building_status,
                issues=building_issues,
                compliance_checks=building_results,
                summary=(
                    f"Building code compliance check: {len(building_results)} checks performed, "
                    f"{len(building_failures)} failures, {len(building_warnings)} warnings."
                ),
            )
        )

        # Fire safety checks
        fire_results = self.compliance_checker.fire_safety_compliance()

        fire_failures = [r for r in fire_results if r.status == ComplianceStatus.FAILED]

        if fire_failures:
            fire_status = ComplianceStatus.FAILED
        else:
            fire_status = ComplianceStatus.PASSED

        fire_issues = []
        for failure in fire_failures:
            fire_issues.append(
                IssueItem(
                    severity=IssueSeverity.ERROR,
                    category="structural",
                    code=f"IFC_{failure.section.replace('.', '_')}",
                    message=f"Fire code {failure.section} issue: {failure.requirement}",
                    location="Fire Safety",
                    recommendation=failure.notes or "Review fire safety requirements",
                    reference=f"{failure.code_name} Section {failure.section}",
                )
            )

        results.append(
            ValidationResult(
                check_name="Fire Safety Compliance",
                category="structural",
                status=fire_status,
                issues=fire_issues,
                compliance_checks=fire_results,
                summary=(
                    f"Fire safety compliance check: {len(fire_results)} checks performed, "
                    f"{len(fire_failures)} failures."
                ),
            )
        )

        return results

    def validate_performance_metrics(
        self,
        metrics: Optional[PerformanceMetrics] = None,
        irradiance_class: str = "medium_irradiance",
    ) -> List[ValidationResult]:
        """Validate system performance metrics.

        Performs comprehensive performance validation including energy yield
        sanity checks, PR validation, loss budget verification, and benchmark
        comparisons.

        Args:
            metrics: Performance metrics to validate (uses self.performance_metrics if not provided)
            irradiance_class: Location irradiance classification

        Returns:
            List of validation results for performance metrics
        """
        if metrics:
            self.performance_metrics = metrics
            self.performance_validator.performance_metrics = metrics

        if self.performance_metrics is None:
            # No performance metrics to validate
            return [
                ValidationResult(
                    check_name="Performance Validation",
                    category="performance",
                    status=ComplianceStatus.NOT_APPLICABLE,
                    summary="No performance metrics provided for validation",
                )
            ]

        # Run performance validation
        is_valid, issues = self.performance_validator.validate_all(
            self.performance_metrics,
            irradiance_class
        )

        # Determine overall status
        critical_issues = [i for i in issues if i.severity == IssueSeverity.CRITICAL]
        error_issues = [i for i in issues if i.severity == IssueSeverity.ERROR]

        if critical_issues:
            status = ComplianceStatus.FAILED
        elif error_issues:
            status = ComplianceStatus.FAILED
        elif any(i.severity == IssueSeverity.WARNING for i in issues):
            status = ComplianceStatus.WARNING
        else:
            status = ComplianceStatus.PASSED

        # Get benchmark comparisons
        benchmarks = self.performance_validator.compare_to_benchmarks()

        results = [
            ValidationResult(
                check_name="Performance Metrics Validation",
                category="performance",
                status=status,
                issues=issues,
                summary=(
                    f"Performance validation: PR={self.performance_metrics.performance_ratio:.2%}, "
                    f"Specific Yield={self.performance_metrics.specific_yield_kwh_kwp:.0f} kWh/kWp, "
                    f"Total Losses={self.performance_metrics.total_losses:.1f}%. "
                    f"{len(critical_issues)} critical, {len(error_issues)} errors, "
                    f"{sum(1 for i in issues if i.severity == IssueSeverity.WARNING)} warnings."
                ),
            )
        ]

        return results

    def validate_complete_design(
        self,
        performance_metrics: Optional[PerformanceMetrics] = None,
        irradiance_class: str = "medium_irradiance",
    ) -> ValidationReport:
        """Perform complete system design validation.

        Orchestrates all validation checks including electrical, structural,
        performance, and code compliance. Generates comprehensive validation report.

        Args:
            performance_metrics: Optional performance metrics to validate
            irradiance_class: Location irradiance classification

        Returns:
            Complete validation report
        """
        # Update performance metrics if provided
        if performance_metrics:
            self.performance_metrics = performance_metrics
            self.performance_validator.performance_metrics = performance_metrics

        # Generate unique report ID
        report_id = f"VAL-{datetime.now().strftime('%Y%m%d')}-{uuid.uuid4().hex[:8].upper()}"

        # Perform electrical validation
        electrical_validation = self.check_electrical_codes()

        # Perform example engineering calculations
        string_calcs = self.calc_verifier.verify_string_calculations()

        # Add calculations to electrical validation
        if electrical_validation:
            electrical_validation[0].calculations.extend(string_calcs)

        # Perform structural validation
        structural_validation = self.verify_structural_requirements()

        # Perform performance validation
        performance_validation = []
        if self.performance_metrics:
            performance_validation = self.validate_performance_metrics(
                self.performance_metrics,
                irradiance_class
            )

        # Collect all compliance results
        all_compliance = (
            self.compliance_checker.nec_690_compliance() +
            self.compliance_checker.iec_60364_compliance() +
            self.compliance_checker.building_code_checks() +
            self.compliance_checker.fire_safety_compliance() +
            self.compliance_checker.local_code_verification()
        )

        # Determine overall status
        failed_checks = [c for c in all_compliance if c.status == ComplianceStatus.FAILED]
        warning_checks = [c for c in all_compliance if c.status == ComplianceStatus.WARNING]

        # Count issues by severity
        all_issues: List[IssueItem] = []
        for validation_list in [electrical_validation, structural_validation, performance_validation]:
            for result in validation_list:
                all_issues.extend(result.issues)

        critical_count = sum(1 for i in all_issues if i.severity == IssueSeverity.CRITICAL)
        error_count = sum(1 for i in all_issues if i.severity == IssueSeverity.ERROR)
        warning_count = sum(1 for i in all_issues if i.severity == IssueSeverity.WARNING)

        # Determine overall validation status
        if failed_checks or critical_count > 0:
            overall_status = ComplianceStatus.FAILED
        elif warning_checks or error_count > 0:
            overall_status = ComplianceStatus.WARNING
        else:
            overall_status = ComplianceStatus.PASSED

        # Generate recommendations
        recommendations = self._generate_recommendations(
            all_issues,
            failed_checks,
            warning_checks
        )

        # Create validation report
        self.validation_report = ValidationReport(
            report_id=report_id,
            system_config=self.config,
            electrical_validation=electrical_validation,
            structural_validation=structural_validation,
            performance_validation=performance_validation,
            code_compliance=all_compliance,
            performance_metrics=self.performance_metrics,
            total_issues=len(all_issues),
            critical_issues=critical_count,
            errors=error_count,
            warnings=warning_count,
            overall_status=overall_status,
            recommendations=recommendations,
            validator="SystemValidator v1.0",
        )

        # Update issue counts
        self.validation_report.count_issues()

        return self.validation_report

    def _generate_recommendations(
        self,
        issues: List[IssueItem],
        failed_checks: List,
        warning_checks: List,
    ) -> List[str]:
        """Generate recommendations based on validation results.

        Args:
            issues: List of all issues found
            failed_checks: List of failed compliance checks
            warning_checks: List of warning compliance checks

        Returns:
            List of recommendation strings
        """
        recommendations = []

        # Critical issues
        critical_issues = [i for i in issues if i.severity == IssueSeverity.CRITICAL]
        if critical_issues:
            recommendations.append(
                f"CRITICAL: Address {len(critical_issues)} critical issues before proceeding. "
                "System cannot be installed until these are resolved."
            )

        # Failed code compliance
        if failed_checks:
            recommendations.append(
                f"Resolve {len(failed_checks)} failed code compliance checks. "
                "Consult with licensed electrical engineer and AHJ."
            )

        # High voltage issues
        voltage_issues = [i for i in issues if "voltage" in i.message.lower()]
        if voltage_issues:
            recommendations.append(
                "Review string configuration to address voltage-related issues. "
                "Consider adjusting modules per string or inverter selection."
            )

        # Performance issues
        perf_issues = [i for i in issues if i.category == "performance"]
        if perf_issues:
            recommendations.append(
                "Review energy model and loss assumptions. Verify irradiance data "
                "and performance ratio calculations against industry benchmarks."
            )

        # Structural issues
        structural_issues = [i for i in issues if i.category == "structural"]
        if structural_issues:
            recommendations.append(
                "Obtain stamped structural calculations from licensed engineer. "
                "Verify wind and snow load calculations per local building codes."
            )

        # General recommendations
        if not critical_issues and not failed_checks:
            recommendations.append(
                "Design meets primary validation criteria. Proceed with detailed "
                "engineering and AHJ submittal."
            )

        if warning_checks:
            recommendations.append(
                f"Review {len(warning_checks)} warning items to optimize design. "
                "While not critical, addressing these may improve system performance."
            )

        # Always recommend professional review
        recommendations.append(
            "Have design reviewed and stamped by licensed Professional Engineer "
            "before submission to Authority Having Jurisdiction."
        )

        return recommendations

    def generate_validation_report(
        self,
        regenerate: bool = False
    ) -> ValidationReport:
        """Generate or retrieve validation report.

        Args:
            regenerate: If True, regenerate the report even if one exists

        Returns:
            Validation report

        Raises:
            ValueError: If no validation has been performed yet
        """
        if self.validation_report is None or regenerate:
            return self.validate_complete_design()

        return self.validation_report

    def get_validation_summary(self) -> Dict[str, any]:
        """Get summary of validation results.

        Returns:
            Dictionary with validation summary statistics

        Raises:
            ValueError: If no validation has been performed yet
        """
        if self.validation_report is None:
            raise ValueError("No validation report available. Run validate_complete_design() first.")

        return {
            "report_id": self.validation_report.report_id,
            "system_name": self.config.system_name,
            "system_type": self.config.system_type.value,
            "capacity_kw": self.config.capacity_kw,
            "overall_status": self.validation_report.overall_status.value,
            "total_issues": self.validation_report.total_issues,
            "critical_issues": self.validation_report.critical_issues,
            "errors": self.validation_report.errors,
            "warnings": self.validation_report.warnings,
            "compliance_checks": len(self.validation_report.code_compliance),
            "compliance_passed": sum(
                1 for c in self.validation_report.code_compliance
                if c.status == ComplianceStatus.PASSED
            ),
            "compliance_failed": sum(
                1 for c in self.validation_report.code_compliance
                if c.status == ComplianceStatus.FAILED
            ),
            "recommendations_count": len(self.validation_report.recommendations),
            "validation_date": self.validation_report.report_date.isoformat(),
        }

    def export_report_json(self, filepath: str) -> None:
        """Export validation report to JSON file.

        Args:
            filepath: Path to output JSON file

        Raises:
            ValueError: If no validation report available
        """
        if self.validation_report is None:
            raise ValueError("No validation report available. Run validate_complete_design() first.")

        with open(filepath, 'w') as f:
            f.write(self.validation_report.model_dump_json(indent=2))
